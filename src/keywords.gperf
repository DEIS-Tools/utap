struct Keyword { char *name; int token; int32_t syntax; }
%%
const,			T_CONST,	SYNTAX_OLD | SYNTAX_NEW
guard,			T_GUARD,	SYNTAX_OLD | SYNTAX_NEW
sync,			T_SYNC,		SYNTAX_OLD | SYNTAX_NEW
assign,			T_ASSIGN,	SYNTAX_OLD | SYNTAX_NEW
process,		T_PROCESS,	SYNTAX_OLD | SYNTAX_NEW
state,			T_STATE,	SYNTAX_OLD | SYNTAX_NEW
init,			T_INIT,		SYNTAX_OLD | SYNTAX_NEW
trans,			T_TRANS,	SYNTAX_OLD | SYNTAX_NEW
urgent,			T_URGENT,	SYNTAX_OLD | SYNTAX_NEW
commit,			T_COMMIT,	SYNTAX_OLD | SYNTAX_NEW
broadcast,       	T_BROADCAST,	SYNTAX_OLD | SYNTAX_NEW
system,			T_SYSTEM,	SYNTAX_OLD | SYNTAX_NEW
true,			T_TRUE,		SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
false,			T_FALSE,	SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
and,			T_KW_AND,	SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
or,			T_KW_OR,	SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
not,			T_KW_NOT,	SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
imply,			T_KW_IMPLY,	SYNTAX_OLD | SYNTAX_NEW | SYNTAX_PROPERTY
for,			T_FOR,		SYNTAX_NEW
while,			T_WHILE,	SYNTAX_NEW
do, 			T_DO,		SYNTAX_NEW
break,			T_BREAK,	SYNTAX_NEW
continue, 		T_CONTINUE,	SYNTAX_NEW
switch, 		T_SWITCH,	SYNTAX_NEW
if, 			T_IF,		SYNTAX_NEW
else, 			T_ELSE,		SYNTAX_NEW
case, 			T_CASE,		SYNTAX_NEW
default, 		T_DEFAULT,	SYNTAX_NEW
return, 		T_RETURN,	SYNTAX_NEW
typedef,		T_TYPEDEF,	SYNTAX_NEW
struct,			T_STRUCT,	SYNTAX_NEW
deadlock,		T_DEADLOCK,	SYNTAX_PROPERTY
quit,			T_QUIT,		SYNTAX_PROPERTY
rate,			T_RATE,		SYNTAX_GUIDING
before_update,		T_BEFORE,	SYNTAX_GUIDING
after_update,		T_AFTER,	SYNTAX_GUIDING
cost,			T_COST,		SYNTAX_GUIDING
chan_priority,		T_CHAN_PRIORITY, SYNTAX_OLD | SYNTAX_NEW
proc_priority,		T_PROC_PRIORITY, SYNTAX_OLD | SYNTAX_NEW
%%

bool isKeyword(const char *id, uint32_t syntax)
{
    const Keyword *keyword = Keywords::in_word_set(id, strlen(id));
    return (keyword != NULL && (keyword->syntax & syntax));
}
